/*
 * Copyright 2014 Nedim Srndic, University of Tuebingen
 *
 * This file is part of Hidost.

 * Hidost is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Hidost is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Hidost.  If not, see <http://www.gnu.org/licenses/>.
 *
 * cacher.cpp
 *  Created on: Nov 21, 2013
 */

/*
 * This program extracts PDF structural paths from a set of PDF files
 * given as input and caches them. All paths extracted from a single
 * PDF file are cached together as a list of paths in one file.
 * The location of the cache file is generated by a regular
 * expression, substituting a pattern of the input path with a
 * new path.
 */

#include <cstdlib>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#define BOOST_FILESYSTEM_VERSION 3
#include <boost/filesystem.hpp>
#include <boost/program_options.hpp>
#include <boost/thread.hpp>	// boost::mutex
#include <quickly/DataAction.h>
#include <quickly/ThreadPool.h>

namespace fs = boost::filesystem;
namespace po = boost::program_options;

class DataActionImpl: public quickly::DataActionBase {
private:
    explicit DataActionImpl(unsigned int id) :
            DataActionBase(id) {
    }
    // A mutex for thread safety
    static boost::mutex print_mutex;
    // A vector of file names
    static std::vector<std::string> files;
    // The directory where to store the caches
    static fs::path cache_dir;
public:
    // Dummy constructor
    DataActionImpl() :
            DataActionBase(UINT_MAX) {
    }
    virtual ~DataActionImpl() {
    }
    // Virtual constructor
    virtual DataActionImpl *create(unsigned int id) {
        return new DataActionImpl(id);
    }

    // Static constructor
    static void init(const std::string &cache_dir);
    static void addFile(const std::string &newfile) {
        files.push_back(newfile);
    }
    static const std::vector<std::string> &getFiles() {
        return files;
    }

    // Overridden doFull() method
    virtual void doFull(std::stringstream &databuf);
};

boost::mutex DataActionImpl::print_mutex;
std::vector<std::string> DataActionImpl::files;
fs::path DataActionImpl::cache_dir;

void DataActionImpl::doFull(std::stringstream &databuf) {
    fs::path of_path(DataActionImpl::cache_dir);
    of_path /= files[getId()];
     
    // Open the cache file
    std::ofstream of(of_path.c_str(), std::ios::binary | std::ios::trunc);
    if (!of) {
        // Try recreating the missing directory structure
        if (not fs::create_directories(of_path.parent_path())) {
            std::cerr << "Unable to open file " << of_path.c_str() << std::endl;
            return;
        } else {
            // Open the cache file again
            of.open(of_path.c_str(), std::ios::binary | std::ios::trunc);
            if (!of) {
                std::cerr << "Unable to open file " << of_path.c_str()
                          << std::endl;
                return;
            }
        }
    }
    // Copy the output from the child into the cache file
    while (databuf.good() and databuf.peek() != EOF) {
        of.put(databuf.get());
    }
    of.close();
}

void DataActionImpl::init(const std::string &cache_dir) {
    if (not fs::is_directory(cache_dir)) {
        std::cerr << "Please specify an existing directory for --cache."
                  << std::endl;
        std::exit(1);
    }
    DataActionImpl::cache_dir = fs::canonical(cache_dir);
}

std::vector<std::string> &split(const std::string &s, char delim,
                                std::vector<std::string> &elems) {
    std::stringstream ss(s);
    std::string item;
    while (std::getline(ss, item, delim)) {
        elems.push_back(item);
    }
    return elems;
}

std::vector<std::string> split(const std::string &s, char delim) {
    std::vector<std::string> elems;
    split(s, delim, elems);
    return elems;
}

po::variables_map parse_arguments(int argc, char *argv[]) {
    po::options_description desc(
            "This program runs an executable on the specified files"
            " and stores the outputs. The location of the output files "
            "is given by substituting the 'pattern' in the input file "
            "location with 'sub'. Allowed options");
    desc.add_options()("help", "produce help message")
            ("input-file,i",
                    po::value<std::string>()->required(),
                    "a list of input files, one per line")
            ("compact", "perform feature compaction")
            ("values", "use values instead of presence as features")
            ("cache,c",
                    po::value<std::string>()->required(),
                    "where to cache")
            ("vm-limit,m",
                    po::value<unsigned int>()->default_value(0U),
                    "limit the virtual memory of child processes in "
                    "MB (default: no limit)")
            ("cpu-time,t",
                    po::value<unsigned int>()->default_value(0U),
                    "limit the CPU time of child processes in seconds "
                    "(default: no limit)")
            ("parallel,N",
                    po::value<unsigned int>()->default_value(0U),
                    "number of child processes to run in parallel "
                    "(default: number of cores minus one)");

    po::variables_map vm;
    po::store(po::command_line_parser(argc, argv).options(desc).run(), vm);

    if (vm.count("help")) {
        std::cout << desc << std::endl;
        std::exit(EXIT_SUCCESS);
    }

    try {
        po::notify(vm);
    } catch (std::exception &e) {
        std::cerr << e.what() << std::endl << std::endl << desc << std::endl;
        std::exit(EXIT_FAILURE);
    }
    return vm;
}

int run(int argc, char *argv[]) {
    // Parse arguments
    po::variables_map vm = parse_arguments(argc, argv);
    const std::string INPUT_FILE = vm["input-file"].as<std::string>();
    const bool DO_COMPACT = vm.count("compact") > 0;
    const bool USE_VALUES = vm.count("values") > 0;
    const std::string CACHE_DIR = vm["cache"].as<std::string>();
    const unsigned int VM_LIMIT = vm["vm-limit"].as<unsigned int>();
    const unsigned int CPU_LIMIT = vm["cpu-time"].as<unsigned int>();
    const unsigned int PARALLEL = vm["parallel"].as<unsigned int>();
    DataActionImpl::init(CACHE_DIR);

    // Read file list
    {
        std::string line;
        std::ifstream ifile(INPUT_FILE, std::ios::binary);
        while (std::getline(ifile, line)) {
            fs::path ff(line);
            if (not fs::exists(ff)) {
                std::cerr << "Skipping nonexistent file " << line << std::endl;
            } else if (fs::is_directory(ff)) {
		std::cerr << "Skipping directory " << line << std::endl;
	    }else {
                DataActionImpl::addFile(fs::canonical(line).string());
            }
        }
        ifile.close();
    }

    // Construct a vector of command-line arguments
    std::vector<const char * const *> argvs;
    const char *prog_name = "${CMAKE_CURRENT_BINARY_DIR}/${PDF2PATHS_EXECUTABLE_NAME}";
    if (USE_VALUES) {
        prog_name = "${CMAKE_CURRENT_BINARY_DIR}/${PDF2VALS_EXECUTABLE_NAME}";
    }
    for (const auto &fname : DataActionImpl::getFiles()) {
        const char **child_argv = nullptr;
        child_argv = new const char *[4] {prog_name,
                                          fname.c_str(),
                                          (DO_COMPACT ? "y" : "n"),
                                          nullptr};
        argvs.push_back(child_argv);
    }

    // Prepare the data action and perform scan
    DataActionImpl dummy;
    quickly::ThreadPool pool(prog_name, argvs, &dummy, PARALLEL);
    pool.setVmLimit(VM_LIMIT * 1024U * 1024U);
    pool.setCpuLimit(CPU_LIMIT);
    pool.setVerbosity(5U);
    pool.run();
    return EXIT_SUCCESS;
}

int main(int argc, char *argv[]) {
	try {
		return run(argc, argv);
	} catch (std::exception &e) {
		std::cerr << "Exception caught: " << e.what() << std::endl;
		return EXIT_FAILURE;
	} catch (const char *e) {
		std::cerr << "Exception caught: " << e << std::endl;
		return EXIT_FAILURE;
	} catch (...) {
		std::cerr << "Unexpected exception caught." << std::endl;
		return EXIT_FAILURE;
	}
}

